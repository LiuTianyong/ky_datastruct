```c
#include<stdio.h>
#include<stdlib.h>

//线性表的链式存储又称为单链表,本部分所有代码都是带头结点的操作
typedef struct LNode           //定义单链表结点类型
{
    int data;            //数据域
    struct LNode *next;       //指针域
} LNode, *LinkList;            //单链表的定义

//建立链表的2种方法  头插法 尾插法
//1.头插法
LinkList CreatList1()
{
    //从表尾到表头逆向建立单链表L，每次都在头结点之后插入
    LinkList L = (LinkList)malloc(sizeof(LNode));  //创建头结点；
    LNode *s;
    int x;
    L->next = NULL;                       //初始化为NULL
    scanf("%d", &x);
    while (x != -1)//当x=-1的时候结束插入
    {
        s = (LNode *)malloc(sizeof(LNode)); //创建新节点
        s->data = x;//数据域赋值
        s->next = L->next;
        L->next = s;
        scanf("%d", &x);
    }
    return L;
}
//2.尾插法
LinkList CreatList2()
{
    //从表头到表尾正向建立，每次均在表尾插入元素
    LinkList L = (LinkList)malloc(sizeof(LNode));// 创建头结点
    int x; //输入的数据
    LNode *s; // 指针
    LNode *ss = L;//储尾指针；让尾指针先等于L
    L->next = NULL;
    scanf("%d", &x);
    while (x != -1)//当x=-1的时候结束插入
    {
        s = (LNode *)malloc(sizeof(LNode));
        s->data = x;
        ss->next = s;
        ss = s;
        scanf("%d", &x);
    }
    ss->next = NULL;//最后一个元素的next为NULL
    return L;
}
//3.插入结点操作
//2个函数  一个是 找到第i个位置的函数，另一个是插入函数
LinkList GetElem(LinkList L, int i)
{
    LNode *p = L;
    while (i-- > 0 && p)
    {
        p = p->next;
    }
    return p;
}
int Insert(LinkList L, int i, int x)
{
    //检查合法性
    //{}
    LNode *s = (LNode*)malloc(sizeof(LNode));
    s->next = GetElem(L, i - 1)->next;
    GetElem(L, i - 1)->next = s;         //调用返回 第i个位置的函数
    s->data = x;
    return 1;
}
//4.删除结点操作
int Delete(LinkList L, int i)
{
    //检查合法性
    //{}
    LNode *p; //找到的前驱
    LNode *q; //要找的那个
    p = GetElem(L, i - 1);
    q = p->next;
    p->next = q->next;
    free(q);
    return 1;

}
//5.求表长度
int GetLength(LinkList L)
{
    if (L->next == NULL)
    {
        return NULL;
    }
    int i = 0;
    LinkList p = L->next;
    while (p != NULL)
    {
        i++;
        p = p->next;
    }
    return i;
}
//6.输出表
void Display(LinkList L)
{
    if (L->next == NULL)
        return;
    LinkList p = L->next;
    while (p != NULL)
    {
        printf("%d ",p->data);
        p = p->next;
    }
    printf("\n");
}
int main()
{
    LinkList L = CreatList1();//创建链表,随便输入几个数,输入-1停止输入
    Display(L);//打印表
    printf("表的长度为:%d\n", GetLength(L));//输出长度

    Insert(L, 1, 3);//在第一个位置前面插入3
    Display(L);//打印表
    printf("表的长度为:%d\n", GetLength(L));//输出长度

    Delete(L, 2);//删除第二个位置的元素
    Display(L);//打印表
    printf("表的长度为:%d\n",GetLength(L));//输出长度
}

```



```c
#include <stdio.h>
#include <stdlib.h>


typedef int Element;

typedef struct LNode {
    Element data;
    struct LNode *next;
} LNode, *LinkList;

// 头插法
LinkList createListL(int a[], int n);

// 尾插法
LinkList createListR(int a[], int n);

// 输出表
void Display(LinkList L);

int main() {

    Element a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    for (int i = 0; i < 10; ++i) {
        printf("%d ", a[i]);
    }
    printf("\n数组初始化完成\n");
//    LinkList L = createListL(a, 10);
    LinkList L = createListR(a, 10);
    Display(L);
    return 0;
}

// 头插法
LinkList createListL(int a[], int n) {
    LinkList L = (LinkList) malloc(sizeof(LNode));
    L->next = NULL;
    LNode *s;
    for (int i = 0; i < n; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = a[i];
        s->next = L->next;
        L->next = s;
    }
    return L;
}

// 尾插法
LinkList createListR(int a[], int n) {
    LinkList L = (LinkList) malloc(sizeof(LNode));
    LNode *s;
    LNode *p = L;
    L->next = NULL;

    for (int i = 0; i < n; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = a[i];
        p->next = s;
        p = s;
    }
    p->next = NULL;
    return L;
}

void Display(LinkList L) {
    if (L->next == NULL) {
        printf("链表为空");
        return;
    }

    LinkList P = L->next;
    while (P != NULL) {
        printf("%d ", P->data);
        P = P->next;
    }
}
```

